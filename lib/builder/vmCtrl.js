// Generated by CoffeeScript 1.9.3
(function() {
  var Schema, Vm, VmBuilder, keystore, netem, util;

  Vm = require('lxcdriver');

  util = require('util');

  netem = require('linuxtcdriver');

  keystore = require('mem-db');

  Schema = require('./../schema').nodeschema;

  VmBuilder = (function() {
    function VmBuilder() {
      this.registry = new keystore("vmbuilder", Schema);
      this.vmobjs = {};
    }

    VmBuilder.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    VmBuilder.prototype.get = function(id, callback) {
      return callback(this.registry.get(id));
    };

    VmBuilder.prototype.create = function(data, callback) {
      var id, vmobj;
      id = this.registry.add(data);
      if (id instanceof Error || id === false) {
        return callback(new Error("invalid Schema"));
      }
      vmobj = new Vm(data.name);
      data.status = "creation-in-progress";
      this.registry.update(id, data);
      callback({
        "id": id,
        "status": vmobj.state
      });
      return vmobj.clone(data.image, (function(_this) {
        return function(result) {
          var j, len, ref, text, x;
          util.log("clone vm " + result);
          if (result instanceof Error) {
            data.status = vmobj.state;
            data.reason = "VM already exists";
            _this.registry.update(id, data);
            return;
          }
          util.log("state is " + vmobj.state);
          vmobj.deleteFile("/etc/network/interfaces");
          if (data.ifmap != null) {
            ref = data.ifmap;
            for (j = 0, len = ref.length; j < len; j++) {
              x = ref[j];
              if (x.type === "mgmt") {
                text = "\nauto " + x.ifname + "\niface " + x.ifname + " inet static \n\t address " + x.ipaddress + " \n\t netmask " + x.netmask + " \n";
                vmobj.appendFile("/etc/network/interfaces", text);
              } else {
                vmobj.addEthernetInterface(x.veth, x.hwAddress);
                text = "\nauto " + x.ifname + "\niface " + x.ifname + " inet static \n\t address " + x.ipaddress + " \n\t netmask " + x.netmask + " \n\t gateway " + x.gateway + "\n";
                vmobj.appendFile("/etc/network/interfaces", text);
              }
            }
          }
          data.status = vmobj.state;
          _this.registry.update(id, data);
          _this.vmobjs[id] = vmobj;
        };
      })(this));
    };

    VmBuilder.prototype.start = function(id, callback) {
      var vmdata, vmobj;
      console.log("start called id is ", id);
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      console.log("start ", vmdata);
      vmobj = this.vmobjs[id];
      if (vmobj == null) {
        return callback(new Error("vm obj not found"));
      }
      this.configStartup(vmdata);
      return vmobj.start((function(_this) {
        return function(res) {
          util.log("startvm" + res);
          if (res === true) {
            vmdata.status = vmobj.state;
            _this.registry.update(id, vmdata);
            return callback({
              "id": id,
              "status": vmdata.status
            });
          } else {
            vmdata.status = "failed";
            vmddata.reason = "failed to start";
            _this.registry.update(vmdata.id, vmdata);
            return callback({
              "id": vmdata.id,
              "status": vmdata.status,
              "reason": vmdata.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.provision = function(id, callback) {
      var vmdata, vmobj;
      console.log("provision is called ", id);
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      console.log("provision ", vmdata);
      vmobj = this.vmobjs[id];
      if (vmobj == null) {
        return callback(new Error("vm obj not found"));
      }
      return callback({
        "id": vmdata.id,
        "status": "provisioned"
      });
    };

    VmBuilder.prototype.stop = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.stop((function(_this) {
        return function(result) {
          util.log("stopvm" + result);
          if (result === true) {
            vmdata.status = vmobj.state;
            _this.registry.update(id, vmdata);
            return callback({
              "id": vmdata.id,
              "status": vmdata.status
            });
          } else {
            vmdata.status = "failed";
            vmdata.reason = "failed to stop";
            _this.registry.update(id, vmdata);
            return callback({
              "id": vmdata.id,
              "status": vmdata.status,
              "reason": vmdata.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.del = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.stop((function(_this) {
        return function(res) {
          return vmobj.destroy(function(result) {
            util.log("deleteVM " + result);
            if (result === true) {
              vmdata.status = vmobj.state;
              _this.registry.remove(vmdata.id);
              return callback({
                "id": vmdata.id,
                "status": vmdata.status
              });
            } else {
              vmdata.status = "failed";
              vmddata.reason = "failed to stop";
              _this.registry.update(vmdata.id, vmdata);
              return callback({
                "id": vmdata.id,
                "status": vmdata.status,
                "reason": vmdata.reason
              });
            }
          });
        };
      })(this));
    };

    VmBuilder.prototype.status = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.runningstatus((function(_this) {
        return function(res) {
          util.log("statusvm" + res);
          vmdata.status = res;
          _this.registry.update(vmdata.id, vmdata);
          return callback({
            "id": vmdata.id,
            "status": vmdata.status
          });
        };
      })(this));
    };

    VmBuilder.prototype.setLinkChars = function(id, callback) {
      var Netem1, i, j, len, ref, vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      ref = vmdata.ifmap;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        util.log("Vmctrl - setLinkChars " + JSON.stringify(i));
        if (i.config != null) {
          Netem1 = new netem(i.veth, i.config);
          Netem1.create();
        }
      }
      return callback(true);
    };

    VmBuilder.prototype.configStartup = function(vmdata) {
      var Netem, command, i, j, k, l, len, len1, len2, len3, m, ospfconf, ref, ref1, ref2, ref3, text, vmobj, zebraconf;
      util.log("in configStartup routine", JSON.stringify(vmdata));
      vmobj = this.vmobjs[vmdata.id];
      ref = vmdata.ifmap;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        util.log("Vmctrl - setLinkChars " + JSON.stringify(i));
        if (i.config != null) {
          Netem = new netem(i.ifname, i.config);
          console.log(Netem.commands);
          text = " ";
          ref1 = Netem.commands;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            command = ref1[k];
            console.log("command ", command);
            text += "\n " + command;
          }
          text += "\n";
          console.log("string command ", text);
          vmobj.appendFile("/etc/init.d/rc.local", text);
        }
      }
      if (vmdata.type === "router") {
        util.log('its router');
        zebraconf = "hostname zebra \npassword zebra \nenable password zebra \n";
        ref2 = vmdata.ifmap;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          i = ref2[l];
          zebraconf += "interface  " + i.ifname + " \n";
          if (i.type === "wan") {
            zebraconf += "   ip address " + i.ipaddress + "/30 \n";
          }
          if (i.type === "lan") {
            zebraconf += "   ip address " + i.ipaddress + "/27 \n";
          }
          if (i.type === "mgmt") {
            zebraconf += "   ip address " + i.ipaddress + "/24 \n";
          }
        }
        util.log("zebrafile " + zebraconf);
        vmobj.appendFile("/etc/zebra.conf", zebraconf);
        ospfconf = "hostname ospf \npassword zebra \nenable password zebra \nrouter ospf\n  ";
        ref3 = vmdata.ifmap;
        for (m = 0, len3 = ref3.length; m < len3; m++) {
          i = ref3[m];
          if (i.type !== "mgmt") {
            ospfconf += "   network " + i.ipaddress + "/24 area 0 \n";
          }
        }
        util.log("ospfconffile " + ospfconf);
        vmobj.appendFile("/etc/ospf.conf", ospfconf);
        text = "\n/usr/lib/quagga/zebra -f /etc/zebra.conf -d & \n /usr/lib/quagga/ospfd -f /etc/ospf.conf -d & \n";
        vmobj.appendFile("/etc/init.d/rc.local", text);
        util.log("its router- to be returned here");
      } else {
        util.log('its host');
        text = "\nnodejs /node_modules/testagent/lib/app.js > /var/log/testagent.log & \n  iperf -s > /var/log/iperf_tcp_server.log & \n iperf -s -u > /var/log/iperf_udp_server.log & \n";
        vmobj.appendFile("/etc/init.d/rc.local", text);
      }
    };

    return VmBuilder;

  })();

  module.exports = new VmBuilder;

}).call(this);
