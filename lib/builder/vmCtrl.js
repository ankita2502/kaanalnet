// Generated by CoffeeScript 1.9.3
(function() {
  var StormData, StormRegistry, VmBuilder, VmData, VmRegistry, netem, util, vm,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StormData = require('stormdata');

  StormRegistry = require('stormregistry');

  vm = require('./lxcdriver');

  util = require('util');

  netem = require('./iproute2driver');

  VmRegistry = (function(superClass) {
    extend(VmRegistry, superClass);

    function VmRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new VmData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      VmRegistry.__super__.constructor.call(this, filename);
    }

    VmRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof VmData)) {
        return;
      }
      return entry = VmRegistry.__super__.add.call(this, data.id, data);
    };

    VmRegistry.prototype.update = function(data) {
      return VmRegistry.__super__.update.call(this, data.id, data);
    };

    VmRegistry.prototype.get = function(key) {
      var entry;
      entry = VmRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof VmData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return VmRegistry;

  })(StormRegistry);

  VmData = (function(superClass) {
    var Schema;

    extend(VmData, superClass);

    Schema = {
      name: "vm",
      type: "object",
      required: true,
      properties: {
        name: {
          "type": "string",
          "required": true
        },
        projectid: {
          "type": "string",
          "required": false
        },
        type: {
          "type": "string",
          "required": false
        },
        memory: {
          "type": "string",
          "required": false
        },
        vcpus: {
          "type": "string",
          "required": false
        },
        ifmap: {
          type: "array",
          required: false,
          items: {
            type: "object",
            name: "ifmapp",
            required: false,
            properties: {
              ifname: {
                type: "string",
                "required": true
              },
              hwAddress: {
                type: "string",
                "required": true
              },
              brname: {
                type: "string",
                "required": false
              },
              ipaddress: {
                type: "string",
                "required": true
              },
              netmask: {
                type: "string",
                "required": true
              },
              gateway: {
                tye: "string",
                "required": false
              },
              type: {
                tye: "string",
                "required": true
              },
              config: {
                type: "object",
                required: false
              }
            }
          }
        }
      }
    };

    function VmData(id, data) {
      VmData.__super__.constructor.call(this, id, data, Schema);
    }

    return VmData;

  })(StormData);

  VmBuilder = (function() {
    VmBuilder.records = [];

    function VmBuilder() {
      this.registry = new VmRegistry;
      this.registry.on('load', function(key, val) {});
    }

    VmBuilder.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    VmBuilder.prototype.get = function(data, callback) {
      return callback(this.registry.get(data));
    };

    VmBuilder.prototype.create = function(data, callback) {
      var err, vmdata;
      try {
        return vmdata = new VmData(null, data);
      } catch (_error) {
        err = _error;
        util.log("invalid schema" + err);
        return callback(new Error("Invalid Input "));
      } finally {
        vmdata.data.status = "creation-in-progress";
        this.registry.add(vmdata);
        callback({
          "id": vmdata.id,
          "status": vmdata.data.status
        });
        console.log("stopcontainer", vmdata.data.name);
        vm.stopContainer(vmdata.data.name, (function(_this) {
          return function(result) {
            return vm.destroyContainer(vmdata.data.name, function(result) {
              return vm.createContainer(vmdata.data.name, "device", function(result) {
                var j, len, ref, result1, result2, x;
                util.log("createvm " + result);
                if (result === false) {
                  vmdata.data.status = "failure";
                  vmdata.data.reason = "VM already exists";
                  _this.registry.update(vmdata.id, vmdata.data);
                  return;
                }
                if (vmdata.data.ifmap != null) {
                  ref = vmdata.data.ifmap;
                  for (j = 0, len = ref.length; j < len; j++) {
                    x = ref[j];
                    if (x.type === "mgmt") {
                      result2 = vm.assignIP(vmdata.data.name, x.ifname, x.ipaddress, x.netmask, null);
                      console.log("assignIP " + result2);
                      if (result2 === false) {
                        vmdata.data.status = "failure";
                        vmdata.data.reason = "Fail to assign mgmt ip";
                        _this.registry.update(vmdata.id, vmdata.data);
                        return;
                      }
                    } else {
                      result1 = vm.addEthernetInterface(vmdata.data.name, x.veth, x.hwAddress);
                      console.log("addEthernetInterface " + result1);
                      if (result === false) {
                        vmdata.data.status = "failure";
                        vmdata.data.reason = "Fail to add Interface";
                        _this.registry.update(vmdata.id, vmdata.data);
                        return;
                      }
                      result2 = vm.assignIP(vmdata.data.name, x.ifname, x.ipaddress, x.netmask, x.gateway);
                      console.log("assignIP " + result2);
                      if (result === false) {
                        vmdata.data.status = "failure";
                        vmdata.data.reason = "Fail to add Interface";
                        _this.registry.update(vmdata.id, vmdata.data);
                        return;
                      }
                    }
                  }
                }
                vmdata.data.id = vmdata.id;
                vmdata.data.status = "created";
                _this.registry.update(vmdata.id, vmdata.data);
              });
            });
          };
        })(this));
      }
    };

    VmBuilder.prototype.status = function(data, callback) {
      var vmdata;
      vmdata = this.registry.get(data);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      return vm.getStatus(vmdata.data.name, (function(_this) {
        return function(res) {
          util.log("statusvm" + res);
          vmdata.data.status = res;
          _this.registry.update(vmdata.id, vmdata.data);
          return callback({
            "id": vmdata.id,
            "status": vmdata.data.status
          });
        };
      })(this));
    };

    VmBuilder.prototype.start = function(data, callback) {
      var vmdata;
      vmdata = this.registry.get(data);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      return vm.startContainer(vmdata.data.name, (function(_this) {
        return function(res) {
          util.log("startvm" + res);
          if (res === true) {
            vmdata.data.status = "started";
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status
            });
          } else {
            vmdata.data.status = "failed";
            vmddata.data.reason = "failed to start";
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status,
              "reason": vmdata.data.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.stop = function(data, callback) {
      var vmdata;
      vmdata = this.registry.get(data);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      return vm.stopContainer(vmdata.data.name, (function(_this) {
        return function(result) {
          util.log("stopvm" + result);
          if (result === true) {
            vmdata.data.status = "stopped";
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status
            });
          } else {
            vmdata.data.status = "failed";
            vmdata.data.reason = "failed to stop";
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status,
              "reason": vmdata.data.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.del = function(data, callback) {
      var vmdata;
      vmdata = this.registry.get(data);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      return this.stop(data, (function(_this) {
        return function(res) {
          return vm.destroyContainer(vmdata.data.name, function(result) {
            util.log("deleteVM " + result);
            if (result === true) {
              vmdata.data.status = "deleted";
              _this.registry.remove(vmdata.id);
              return callback({
                "id": vmdata.id,
                "status": vmdata.data.status
              });
            } else {
              vmdata.data.status = "failed";
              vmddata.data.reason = "failed to stop";
              _this.registry.update(vmdata.id, vmdata.data);
              return callback({
                "id": vmdata.id,
                "status": VmDataa.data.status,
                "reason": vmdata.data.reason
              });
            }
          });
        };
      })(this));
    };

    VmBuilder.prototype.setLinkChars = function(data, callback) {
      var i, j, len, ref, results, vmdata;
      vmdata = this.registry.get(data);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      ref = vmdata.data.ifmap;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        util.log("Vmctrl - setLinkChars " + JSON.stringify(i));
        if (i.config != null) {
          netem.setLinkChars(i.veth, i.config, (function(_this) {
            return function(result) {
              return console.log("setLinkCahrs output " + result);
            };
          })(this));
          results.push(callback(true));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    VmBuilder.prototype.packettrace = function(data, callback) {
      var command, exec, j, len, ref, vmdata, x;
      vmdata = this.registry.get(data);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      if (vmdata.data.traceEnabled === true) {
        return callback({
          "id": vmdata.id,
          "status": "Packet Trace already enabled"
        });
      }
      vmdata.data.traceEnabled = true;
      this.registry.update(vmdata.id, vmdata.data);
      if (vmdata.data.ifmap != null) {
        ref = vmdata.data.ifmap;
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          if (x.type !== "mgmt") {
            command = "tcpdump -vv -S -i " + x.veth + " > /var/log/" + x.veth + ".txt &";
            util.log("executing " + command + "...");
            exec = require('child_process').exec;
            exec(command, (function(_this) {
              return function(error, stdout, stderr) {
                util.log("lxcdriver: execute - Error : " + error);
                util.log("lxcdriver: execute - stdout : " + stdout);
                return util.log("lxcdriver: execute - stderr : " + stderr);
              };
            })(this));
          }
        }
        return callback({
          "id": vmdata.id,
          "status": "Packet Trace enabled"
        });
      }
    };

    return VmBuilder;

  })();

  module.exports = new VmBuilder;

}).call(this);
