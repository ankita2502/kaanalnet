// Generated by CoffeeScript 1.9.3
(function() {
  var StormData, StormRegistry, Vm, VmBuilder, VmData, VmRegistry, netem, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StormData = require('stormdata');

  StormRegistry = require('stormregistry');

  Vm = require('lxcdriver');

  util = require('util');

  netem = require('./iproute2driver');

  VmRegistry = (function(superClass) {
    extend(VmRegistry, superClass);

    function VmRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new VmData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      VmRegistry.__super__.constructor.call(this, filename);
    }

    VmRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof VmData)) {
        return;
      }
      return entry = VmRegistry.__super__.add.call(this, data.id, data);
    };

    VmRegistry.prototype.update = function(data) {
      return VmRegistry.__super__.update.call(this, data.id, data);
    };

    VmRegistry.prototype.get = function(key) {
      var entry;
      entry = VmRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof VmData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return VmRegistry;

  })(StormRegistry);

  VmData = (function(superClass) {
    var Schema;

    extend(VmData, superClass);

    Schema = {
      name: "vm",
      type: "object",
      required: true,
      properties: {
        name: {
          "type": "string",
          "required": true
        },
        type: {
          "type": "string",
          "required": false
        },
        virtulization: {
          "type": "string",
          "required": false
        },
        image: {
          "type": "string",
          "required": false
        },
        memory: {
          "type": "string",
          "required": false
        },
        vcpus: {
          "type": "string",
          "required": false
        },
        ifmap: {
          type: "array",
          required: false,
          items: {
            type: "object",
            name: "ifmapp",
            required: false,
            properties: {
              ifname: {
                type: "string",
                "required": true
              },
              hwAddress: {
                type: "string",
                "required": true
              },
              brname: {
                type: "string",
                "required": false
              },
              ipaddress: {
                type: "string",
                "required": true
              },
              netmask: {
                type: "string",
                "required": true
              },
              gateway: {
                tye: "string",
                "required": false
              },
              type: {
                tye: "string",
                "required": true
              },
              config: {
                type: "object",
                required: false
              }
            }
          }
        }
      }
    };

    function VmData(id, data) {
      VmData.__super__.constructor.call(this, id, data, Schema);
    }

    return VmData;

  })(StormData);

  VmBuilder = (function() {
    function VmBuilder() {
      this.registry = new VmRegistry;
      this.vmobjs = {};
    }

    VmBuilder.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    VmBuilder.prototype.get = function(data, callback) {
      return callback(this.registry.get(data));
    };

    VmBuilder.prototype.create = function(data, callback) {
      var err, vmdata, vmobj;
      try {
        return vmdata = new VmData(null, data);
      } catch (_error) {
        err = _error;
        util.log("invalid schema" + err);
        return callback(new Error("Invalid Input "));
      } finally {
        vmdata.data.status = "creation-in-progress";
        this.registry.add(vmdata);
        vmobj = new Vm(vmdata.data.name);
        callback({
          "id": vmdata.id,
          "status": vmobj.state
        });
        vmobj.clone(vmdata.data.image, (function(_this) {
          return function(result) {
            var i, len, ref, text, x;
            util.log("clone vm " + result);
            if (result instanceof Error) {
              vmdata.data.status = vmobj.state;
              vmdata.data.reason = "VM already exists";
              _this.registry.update(vmdata.id, vmdata.data);
              return;
            }
            util.log("state is " + vmobj.state);
            vmobj.deleteFile("/etc/network/interfaces");
            if (vmdata.data.ifmap != null) {
              ref = vmdata.data.ifmap;
              for (i = 0, len = ref.length; i < len; i++) {
                x = ref[i];
                if (x.type === "mgmt") {
                  text = "\nauto " + x.ifname + "\niface " + x.ifname + " inet static \n\t address " + x.ipaddress + " \n\t netmask " + x.netmask + " \n";
                  vmobj.appendFile("/etc/network/interfaces", text);
                } else {
                  vmobj.addEthernetInterface(x.veth, x.hwAddress);
                  text = "\nauto " + x.ifname + "\niface " + x.ifname + " inet static \n\t address " + x.ipaddress + " \n\t netmask " + x.netmask + " \n\t gateway " + x.gateway + "\n";
                  vmobj.appendFile("/etc/network/interfaces", text);
                }
              }
            }
            vmdata.data.id = vmdata.id;
            vmdata.data.status = vmobj.state;
            _this.registry.update(vmdata.id, vmdata.data);
            _this.vmobjs[vmdata.id] = vmobj;
          };
        })(this));
      }
    };

    VmBuilder.prototype.start = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      util.log("start ", vmdata);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      if (vmobj == null) {
        return callback(new Error("vm obj not found"));
      }
      return vmobj.start((function(_this) {
        return function(res) {
          util.log("startvm" + res);
          if (res === true) {
            vmdata.data.status = vmobj.state;
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status
            });
          } else {
            vmdata.data.status = "failed";
            vmddata.data.reason = "failed to start";
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status,
              "reason": vmdata.data.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.stop = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.stop((function(_this) {
        return function(result) {
          util.log("stopvm" + result);
          if (result === true) {
            vmdata.data.status = vmobj.state;
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status
            });
          } else {
            vmdata.data.status = "failed";
            vmdata.data.reason = "failed to stop";
            _this.registry.update(vmdata.id, vmdata.data);
            return callback({
              "id": vmdata.id,
              "status": vmdata.data.status,
              "reason": vmdata.data.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.del = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.stop((function(_this) {
        return function(res) {
          return vmobj.destroy(function(result) {
            util.log("deleteVM " + result);
            if (result === true) {
              vmdata.data.status = vmobj.state;
              _this.registry.remove(vmdata.id);
              return callback({
                "id": vmdata.id,
                "status": vmdata.data.status
              });
            } else {
              vmdata.data.status = "failed";
              vmddata.data.reason = "failed to stop";
              _this.registry.update(vmdata.id, vmdata.data);
              return callback({
                "id": vmdata.id,
                "status": VmDataa.data.status,
                "reason": vmdata.data.reason
              });
            }
          });
        };
      })(this));
    };

    VmBuilder.prototype.status = function(data, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(data);
      if (vmdata == null) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.runningstatus((function(_this) {
        return function(res) {
          util.log("statusvm" + res);
          vmdata.data.status = res;
          _this.registry.update(vmdata.id, vmdata.data);
          return callback({
            "id": vmdata.id,
            "status": vmdata.data.status
          });
        };
      })(this));
    };

    return VmBuilder;

  })();


  /*
  class VmBuilder
      @records = []
      constructor: () ->		
          @registry = new VmRegistry #"/tmp/vm.db"
      		
          @registry.on 'load',(key,val) ->
              #util.log "Loading key #{key} with val #{val}"	
  
      list : (callback) ->
          callback @registry.list()
  
      get: (data, callback) ->
          
          callback @registry.get data
  
      #This create code to be relooked.. To be converted to async
      create:(data,callback) ->
          try         
              vmdata = new VmData(null, data )
          catch err
              util.log "invalid schema" + err
              return callback new Error "Invalid Input "
          finally 
              vmdata.data.status = "creation-in-progress"
              @registry.add vmdata
              callback 
                  "id": vmdata.id
                  "status":vmdata.data.status          
              #Delete the VM if already in the same name exists
              console.log "stopcontainer", vmdata.data.name
  
              vm.stopContainer vmdata.data.name, (result) =>
                  #Need to check the result?
                  vm.destroyContainer vmdata.data.name, (result) =>
                      #Need to check the result
  
                      vm.createContainer vmdata.data.name, vmdata.data.image, (result) =>
                          util.log "createvm " + result
                          if result is false
                              vmdata.data.status = "failed"
                              vmdata.data.reason = "VM already exists"
                              @registry.update vmdata.id, vmdata.data
                              return       
                          vm.clearInterface(vmdata.data.name)
                          if vmdata.data.ifmap?
                              for x in vmdata.data.ifmap                      
                                  if x.type is "mgmt"
                                      result2 = vm.assignIP(vmdata.data.name,x.ifname,x.ipaddress,x.netmask,null)
                                      console.log "assignIP " + result2
                                      if result2 is false
                                          vmdata.data.status = "failure"
                                          vmdata.data.reason = "Fail to assign mgmt ip"
                                          @registry.update vmdata.id, vmdata.data
                                          return 
                                  else # for wan, lan interfaces
                                      #result1 = vm.addEthernetInterface(vmdata.data.name,x.brname,x.hwAddress)              
                                      result1 = vm.addEthernetInterface(vmdata.data.name,x.veth,x.hwAddress)
                                      console.log "addEthernetInterface " + result1               
                                      if result is false
                                          vmdata.data.status = "failure"
                                          vmdata.data.reason = "Fail to add Interface"
                                          @registry.update vmdata.id, vmdata.data
                                          return 
                                      result2 = vm.assignIP(vmdata.data.name,x.ifname,x.ipaddress,x.netmask,x.gateway)
                                      console.log "assignIP " + result2
                                      if result is false
                                          vmdata.data.status = "failure"
                                          vmdata.data.reason = "Fail to add Interface"
                                          @registry.update vmdata.id, vmdata.data
                                          return 
                          #write in to db
                          vmdata.data.id = vmdata.id
                          vmdata.data.status = "created"                                
                          @registry.update vmdata.id, vmdata.data
                          return 
  
      status:(data,callback) ->
          vmdata = @registry.get data
          return callback new Error "VM details not found in DB" unless vmdata?
          vm.getStatus vmdata.data.name, (res) =>
              util.log "statusvm" + res           
              vmdata.data.status = res  
              @registry.update vmdata.id, vmdata.data
              return callback 
                  "id": vmdata.id
                  "status":vmdata.data.status           
  
      start:(data,callback) ->        
          vmdata = @registry.get data
          return callback new Error "VM details not found in DB" unless vmdata?
          @configStartup(vmdata)
          vm.startContainer vmdata.data.name, (res) =>
              util.log "startvm" + res
              if res is true
                  vmdata.data.status = "started"   
                  @registry.update vmdata.id, vmdata.data
                  return callback 
                      "id": vmdata.id
                      "status":vmdata.data.status
              else
                  vmdata.data.status = "failed"
                  vmddata.data.reason = "failed to start"   
                  @registry.update vmdata.id, vmdata.data
                  return callback 
                          "id": vmdata.id
                          "status":vmdata.data.status
                          "reason": vmdata.data.reason
  
      stop:(data,callback) ->
          vmdata = @registry.get data
          return callback new Error "VM details not found in DB" unless vmdata?
          vm.stopContainer vmdata.data.name, (result) =>
              util.log "stopvm" + result
              if result is true
                  vmdata.data.status = "stopped"   
                  @registry.update vmdata.id, vmdata.data
                  return callback  
                      "id":vmdata.id
                      "status":vmdata.data.status
              else
                  vmdata.data.status = "failed"
                  vmdata.data.reason = "failed to stop"   
                  @registry.update vmdata.id, vmdata.data
                  return callback 
                      "id":vmdata.id
                      "status":vmdata.data.status
                      "reason" : vmdata.data.reason
  
      del:(data,callback)->
          vmdata = @registry.get data
          return callback new Error "VM details not found in DB" unless vmdata?
          @stop data, (res) =>
              vm.destroyContainer vmdata.data.name, (result) =>
                  util.log "deleteVM " + result
                  if result is true
                      vmdata.data.status = "deleted"   
                      @registry.remove vmdata.id
                      return callback 
                          "id":vmdata.id
                          "status":vmdata.data.status
                  else
                      vmdata.data.status = "failed"
                      vmddata.data.reason = "failed to stop"   
                      @registry.update vmdata.id, vmdata.data
                      return callback 
                          "id":vmdata.id
                          "status":VmDataa.data.status
                          "reason":vmdata.data.reason
  
      setLinkChars : (data,callback)->
          vmdata = @registry.get data
          return callback new Error "VM details not found in DB" unless vmdata?
          for i in vmdata.data.ifmap            
              util.log "Vmctrl - setLinkChars " + JSON.stringify i
              if i.config?
                  netem.setLinkChars i.veth, i.config,(result)=>
                      console.log "setLinkCahrs output " + result
                  callback true
  
      configStartup :(vmdata)->
          util.log "in configStartup routine", JSON.stringify vmdata
          if vmdata.data.type is "router"
              util.log 'its router'
              vm.updateRouterConfig(vmdata.data.ifmap,vmdata.data.name)            
              vm.updateRouterStartupScript(vmdata.data.name)
              util.log "its router- to be returned here"
              return
          else
              util.log 'its host'
              vm.updateHostStartupScript(vmdata.data.name)                        
              return
   */


  /*
      packettrace:(data, callback)->
          vmdata = @registry.get data
          return callback new Error "VM details not found in DB" unless vmdata?
          #check whether trace is already enabled
          if vmdata.data.traceEnabled is true
              return callback     
                  "id":vmdata.id
                  "status":"Packet Trace already enabled"  
  
          vmdata.data.traceEnabled = true
          @registry.update vmdata.id, vmdata.data
  
          if vmdata.data.ifmap?
              for x in vmdata.data.ifmap  
                  unless x.type is "mgmt"
                      command = "tcpdump -vv -S -i #{x.veth} > /var/log/#{x.veth}.txt &"
                      util.log "executing #{command}..."    
                      exec = require('child_process').exec    
                      exec command, (error, stdout, stderr) =>
                          util.log "lxcdriver: execute - Error : " + error
                          util.log "lxcdriver: execute - stdout : " + stdout
                          util.log "lxcdriver: execute - stderr : " + stderr    
  
              return callback        
                  "id":vmdata.id
                  "status":"Packet Trace enabled"
   */

  module.exports = new VmBuilder;

}).call(this);
