// Generated by CoffeeScript 1.9.3
(function() {
  var Schema, Vm, VmBuilder, keystore, netem, request, util;

  Vm = require('lxcdriver');

  util = require('util');

  netem = require('linuxtcdriver');

  request = require('request-json');

  keystore = require('mem-db');

  Schema = require('./../schema').nodeschema;

  VmBuilder = (function() {
    function VmBuilder() {
      this.registry = new keystore("vmbuilder", Schema);
      this.vmobjs = {};
    }

    VmBuilder.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    VmBuilder.prototype.get = function(id, callback) {
      return callback(this.registry.get(id));
    };

    VmBuilder.prototype.create = function(data, callback) {
      var id, vmobj;
      id = this.registry.add(data);
      if (id instanceof Error || id === false) {
        return callback(new Error("invalid Schema"));
      }
      vmobj = new Vm(data.name);
      data.status = "creation-in-progress";
      this.registry.update(id, data);
      callback({
        "id": id,
        "status": vmobj.state
      });
      return vmobj.clone(data.image, (function(_this) {
        return function(result) {
          var j, k, len, len1, ref, ref1, text, x;
          util.log("clone vm " + result);
          if (result instanceof Error) {
            data.status = vmobj.state;
            data.reason = "VM already exists";
            _this.registry.update(id, data);
            return;
          }
          util.log("state is " + vmobj.state);
          vmobj.deleteFile("/etc/network/interfaces");
          if (data.ifmap != null) {
            ref = data.ifmap;
            for (j = 0, len = ref.length; j < len; j++) {
              x = ref[j];
              if (x.type === "mgmt") {
                text = "\nauto " + x.ifname + "\niface " + x.ifname + " inet static \n\t address " + x.ipaddress + " \n\t netmask " + x.netmask + " \n";
                vmobj.appendFile("/etc/network/interfaces", text);
              } else {
                vmobj.addEthernetInterface(x.veth, x.hwAddress);
                text = "\nauto " + x.ifname + "\niface " + x.ifname + " inet static \n\t address " + x.ipaddress + " \n\t netmask " + x.netmask + " \n\t gateway " + x.gateway + "\n";
                vmobj.appendFile("/etc/network/interfaces", text);
              }
            }
          }
          if (data.lagmap != null) {
            ref1 = data.lagmap;
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              x = ref1[k];
              vmobj.addEthernetInterface(x.veth1, x.hwAddress1);
              vmobj.addEthernetInterface(x.veth2, x.hwAddress2);
              text = "\nauto " + x.lagif1 + "\niface " + x.lagif1 + " inet static \n\t address 0.0.0.0 \n\t netmask 255.255.255.0 \n";
              vmobj.appendFile("/etc/network/interfaces", text);
              text = "\nauto " + x.lagif2 + "\niface " + x.lagif2 + " inet static \n\t address 0.0.0.0 \n\t netmask 255.255.255.0 \n";
              vmobj.appendFile("/etc/network/interfaces", text);
            }
          }
          data.status = vmobj.state;
          if (data.type === "router") {
            if (data.protocol == null) {
              data.protocol = "ospf";
            }
          }
          _this.registry.update(id, data);
          _this.vmobjs[id] = vmobj;
        };
      })(this));
    };

    VmBuilder.prototype.start = function(id, callback) {
      var vmdata, vmobj;
      console.log("start called id is ", id);
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      console.log("start ", vmdata);
      vmobj = this.vmobjs[id];
      if (vmobj == null) {
        return callback(new Error("vm obj not found"));
      }
      this.configStartup(vmdata);
      return vmobj.start((function(_this) {
        return function(res) {
          util.log("startvm" + res);
          if (res === true) {
            vmdata.status = vmobj.state;
            _this.registry.update(id, vmdata);
            return callback({
              "id": id,
              "status": vmdata.status
            });
          } else {
            vmdata.status = "failed";
            vmddata.reason = "failed to start";
            _this.registry.update(vmdata.id, vmdata);
            return callback({
              "id": vmdata.id,
              "status": vmdata.status,
              "reason": vmdata.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.provision = function(id, callback) {
      var vmdata, vmobj;
      console.log("Dummy provisioning is called ", id);
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      console.log("provision ", vmdata);
      vmobj = this.vmobjs[id];
      if (vmobj == null) {
        return callback(new Error("vm obj not found"));
      }
      this.provisionBonding(vmdata);
      return callback({
        "id": vmdata.id,
        "status": "provisioned"
      });
    };

    VmBuilder.prototype.provisionBonding = function(vmdata) {
      var bonddata, bondindex, client, j, lag, len, ref, results;
      bondindex = 0;
      ref = vmdata.lagmap;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        lag = ref[j];
        bonddata = {
          "bondname": lag.bondname,
          "bondmac": lag.bondmac,
          "ipaddress": lag.ipaddress,
          "interfaces": [lag.lagif1, lag.lagif2]
        };
        bondindex++;
        client = request.newClient("http://" + vmdata.mgmtip + ":5051");
        results.push(client.post("/bonding", bonddata, (function(_this) {
          return function(err, res, body) {
            if (err != null) {
              console.log("Post Bonding API Error  %s ", err);
            }
            return console.log("PosT Bonding API result body %s ", JSON.stringify(body));
          };
        })(this)));
      }
      return results;
    };

    VmBuilder.prototype.stop = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.stop((function(_this) {
        return function(result) {
          util.log("stopvm" + result);
          if (result === true) {
            vmdata.status = vmobj.state;
            _this.registry.update(id, vmdata);
            return callback({
              "id": vmdata.id,
              "status": vmdata.status
            });
          } else {
            vmdata.status = "failed";
            vmdata.reason = "failed to stop";
            _this.registry.update(id, vmdata);
            return callback({
              "id": vmdata.id,
              "status": vmdata.status,
              "reason": vmdata.reason
            });
          }
        };
      })(this));
    };

    VmBuilder.prototype.del = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.stop((function(_this) {
        return function(res) {
          return vmobj.destroy(function(result) {
            util.log("deleteVM " + result);
            if (result === true) {
              vmdata.status = vmobj.state;
              _this.registry.remove(vmdata.id);
              return callback({
                "id": vmdata.id,
                "status": vmdata.status
              });
            } else {
              vmdata.status = "failed";
              vmddata.reason = "failed to stop";
              _this.registry.update(vmdata.id, vmdata);
              return callback({
                "id": vmdata.id,
                "status": vmdata.status,
                "reason": vmdata.reason
              });
            }
          });
        };
      })(this));
    };

    VmBuilder.prototype.status = function(id, callback) {
      var vmdata, vmobj;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      vmobj = this.vmobjs[id];
      return vmobj.runningstatus((function(_this) {
        return function(res) {
          util.log("statusvm" + res);
          vmdata.status = res;
          _this.registry.update(vmdata.id, vmdata);
          return callback({
            "id": vmdata.id,
            "status": vmdata.status
          });
        };
      })(this));
    };

    VmBuilder.prototype.setLinkChars = function(id, callback) {
      var Netem, i, j, len, ref, vmdata;
      vmdata = this.registry.get(id);
      if (vmdata === false || vmdata instanceof Error) {
        return callback(new Error("VM details not found in DB"));
      }
      ref = vmdata.ifmap;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        util.log("Vmctrl - setLinkChars " + JSON.stringify(i));
        if (i.config != null) {
          Netem = new netem(i.veth, i.config);
          Netem.create();
        }
      }
      return callback(true);
    };

    VmBuilder.prototype.configStartup = function(vmdata) {
      var Netem, Netem1, bgpconf, command, i, j, k, l, len, len1, len2, len3, len4, m, n, ospfconf, ref, ref1, ref2, ref3, ref4, ripconf, text, vmobj, x, zebraconf;
      util.log("in configStartup routine", JSON.stringify(vmdata));
      vmobj = this.vmobjs[vmdata.id];
      ref = vmdata.ifmap;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        util.log("Vmctrl - setLinkChars " + JSON.stringify(i));
        if (i.config != null) {
          Netem = new netem(i.ifname, i.config);
          console.log(Netem.commands);
          text = " ";
          ref1 = Netem.commands;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            command = ref1[k];
            console.log("command ", command);
            text += "\n " + command;
          }
          text += "\n";
          console.log("string command ", text);
          vmobj.appendFile("/etc/init.d/rc.local", text);
        }
      }
      if (vmdata.lagmap != null) {
        ref2 = vmdata.lagmap;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          x = ref2[l];
          util.log("VmCtrl - LAG interface setlinkchars" + JSON.stringify(x));
          if (x.config != null) {
            Netem = new netem(x.lagif1, x.config);
            console.log(Netem.commands);
            text = " ";
            ref3 = Netem.commands;
            for (m = 0, len3 = ref3.length; m < len3; m++) {
              command = ref3[m];
              console.log("command ", command);
              text += "\n " + command;
            }
            text += "\n";
            Netem1 = new netem(x.lagif2, x.config);
            console.log(Netem1.commands);
            ref4 = Netem1.commands;
            for (n = 0, len4 = ref4.length; n < len4; n++) {
              command = ref4[n];
              console.log("command ", command);
              text += "\n " + command;
            }
            text += "\n";
            console.log("string command ", text);
            vmobj.appendFile("/etc/init.d/rc.local", text);
          }
        }
      }
      if (vmdata.type === "router") {
        util.log('its router');
        zebraconf = this.buildZebraConfig(vmdata);
        vmobj.appendFile("/etc/zebra.conf", zebraconf);
        text = "\n/usr/lib/quagga/zebra -f /etc/zebra.conf -d & \n";
        vmobj.appendFile("/etc/init.d/rc.local", text);
        console.log("vmdata.protocol ", vmdata.protocol);
        switch (vmdata.protocol) {
          case 'rip':
            console.log("ripd case");
            ripconf = this.buildRipConfig(vmdata);
            vmobj.appendFile("/etc/rip.conf", ripconf);
            text = "/usr/lib/quagga/ripd -f /etc/rip.conf -d & \n";
            vmobj.appendFile("/etc/init.d/rc.local", text);
            break;
          case 'ospf':
            console.log("ospf case");
            ospfconf = this.buildOspfConfig(vmdata);
            vmobj.appendFile("/etc/ospf.conf", ospfconf);
            text = "/usr/lib/quagga/ospfd -f /etc/ospf.conf -d & \n";
            vmobj.appendFile("/etc/init.d/rc.local", text);
            break;
          default:
            console.log("default case");
        }
        bgpconf = this.buildBgpConfig(vmdata);
        vmobj.appendFile("/etc/bgp.conf", bgpconf);
        util.log("its router- to be returned here");
      } else {
        util.log('its host');
        text = "\nnodejs /node_modules/testagent/lib/app.js > /var/log/testagent.log & \n  iperf -s > /var/log/iperf_tcp_server.log & \n iperf -s -u > /var/log/iperf_udp_server.log & \n";
        vmobj.appendFile("/etc/init.d/rc.local", text);
      }
    };

    VmBuilder.prototype.buildZebraConfig = function(vmdata) {
      var i, j, len, ref, zebraconf;
      zebraconf = "hostname zebra \npassword zebra \nenable password zebra \n log file /tmp/zebra.log debugging \n";
      ref = vmdata.ifmap;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        zebraconf += "interface  " + i.ifname + " \n";
        if (i.type === "wan") {
          zebraconf += "   ip address " + i.ipaddress + "/29 \n";
        }
        if (i.type === "lan") {
          zebraconf += "   ip address " + i.ipaddress + "/24 \n";
        }
        if (i.type === "mgmt") {
          zebraconf += "   ip address " + i.ipaddress + "/24 \n";
        }
      }
      util.log("zebrafile " + zebraconf);
      return zebraconf;
    };

    VmBuilder.prototype.buildOspfConfig = function(vmdata) {
      var i, j, len, ospfconf, ref;
      ospfconf = "hostname zebra \npassword zebra \nenable password zebra \n log file /tmp/ospf.log debugging \n router ospf\n  ";
      ref = vmdata.ifmap;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if (i.type !== "mgmt") {
          ospfconf += "   network " + i.ipaddress + "/24 area 0 \n";
        }
      }
      util.log("ospfconffile " + ospfconf);
      return ospfconf;
    };

    VmBuilder.prototype.buildBgpConfig = function(vmdata) {
      var bgpconf;
      bgpconf = "hostname zebra \npassword zebra \nenable password zebra \nlog file /tmp/bgp.log debugging  \nrouter bgp 1\n    bgp router-id " + vmdata.mgmtip + "\n    neighbor 10.0.3.1 remote-as 1\n    redistribute connected \n    redistribute ospf\n    redistribute rip\n";
      return bgpconf;
    };

    VmBuilder.prototype.buildRipConfig = function(vmdata) {
      var i, j, len, ref, ripconf;
      ripconf = "hostname zebra \npassword zebra \nenable password zebra \n log file /tmp/rip.log debugging \n  router rip\n  ";
      ref = vmdata.ifmap;
      for (j = 0, len = ref.length; j < len; j++) {
        i = ref[j];
        if (i.type !== "mgmt") {
          ripconf += "   network " + i.ipaddress + "/24 \n";
        }
      }
      util.log("ripconffile " + ripconf);
      return ripconf;
    };

    return VmBuilder;

  })();

  module.exports = new VmBuilder;

}).call(this);
