// Generated by CoffeeScript 1.9.3
(function() {
  var IPManager, StormData, StormRegistry, TestData, TestRegistry, Topology, TopologyData, TopologyMaster, TopologyRegistry, assert, async, extend, ip, log, node, request, sindex, switches, test, util, x,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  assert = require('assert');

  StormRegistry = require('stormregistry');

  StormData = require('stormdata');

  util = require('util');

  request = require('request-json');

  extend = require('util')._extend;

  ip = require('ip');

  async = require('async');

  util = require('util');

  IPManager = require('./IPManager');

  node = require('./Node');

  switches = require('./Switches');

  test = require('./Test');

  log = require('./utils/logger').getLogger();

  log.info("Topology Logger test message");

  x = 0;

  sindex = 1;

  TestRegistry = (function(superClass) {
    extend1(TestRegistry, superClass);

    function TestRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new TestData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      TestRegistry.__super__.constructor.call(this, filename);
    }

    TestRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof TestData)) {
        return;
      }
      return entry = TestRegistry.__super__.add.call(this, data.id, data);
    };

    TestRegistry.prototype.update = function(data) {
      return TestRegistry.__super__.update.call(this, data.id, data);
    };

    TestRegistry.prototype.get = function(key) {
      var entry;
      entry = TestRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof TestData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return TestRegistry;

  })(StormRegistry);

  TestData = (function(superClass) {
    var TestSchema;

    extend1(TestData, superClass);

    TestSchema = {
      name: "Test",
      type: "object",
      properties: {
        name: {
          type: "string",
          required: true
        },
        tests: {
          type: "array",
          items: {
            name: "test",
            type: "object",
            required: true,
            properties: {
              sourcenodes: {
                type: "array",
                items: {
                  type: "string",
                  required: true
                }
              },
              destnodes: {
                type: "array",
                items: {
                  type: "string",
                  required: true
                }
              },
              traffictype: {
                type: "string",
                required: true
              },
              starttime: {
                type: "number",
                required: false
              },
              duration: {
                type: "number",
                required: true
              },
              trafficconfig: {
                type: "object",
                required: true
              }
            }
          }
        }
      }
    };

    function TestData(id, data) {
      TestData.__super__.constructor.call(this, id, data, TestSchema);
    }

    return TestData;

  })(StormData);

  TopologyRegistry = (function(superClass) {
    extend1(TopologyRegistry, superClass);

    function TopologyRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new TopologyData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      TopologyRegistry.__super__.constructor.call(this, filename);
    }

    TopologyRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof TopologyData)) {
        return;
      }
      return entry = TopologyRegistry.__super__.add.call(this, data.id, data);
    };

    TopologyRegistry.prototype.update = function(data) {
      return TopologyRegistry.__super__.update.call(this, data.id, data);
    };

    TopologyRegistry.prototype.get = function(key) {
      var entry;
      entry = TopologyRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof TopologyData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return TopologyRegistry;

  })(StormRegistry);

  TopologyData = (function(superClass) {
    var TopologySchema;

    extend1(TopologyData, superClass);

    TopologySchema = {
      name: "Topology",
      type: "object",
      properties: {
        name: {
          type: "string",
          required: true
        },
        switches: {
          type: "array",
          items: {
            name: "switch",
            type: "object",
            required: true,
            properties: {
              name: {
                type: "string",
                required: false
              },
              type: {
                type: "string",
                required: false
              }
            }
          }
        },
        nodes: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              name: {
                type: "string",
                required: true
              },
              type: {
                type: "string",
                required: false
              }
            }
          }
        },
        links: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              type: {
                type: "string",
                required: true
              },
              switches: {
                type: "array",
                required: false,
                items: {
                  type: "object",
                  required: false
                }
              },
              connected_nodes: {
                type: "array",
                required: false,
                items: {
                  type: "object",
                  required: false,
                  properties: {
                    name: {
                      "type": "string",
                      "required": true
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    function TopologyData(id, data) {
      TopologyData.__super__.constructor.call(this, id, data, TopologySchema);
    }

    return TopologyData;

  })(StormData);

  Topology = (function() {
    function Topology() {
      this.config = {};
      this.sysconfig = {};
      this.status = {};
      this.statistics = {};
      this.switchobj = [];
      this.nodeobj = [];
      this.linksobj = [];
      this.testobjs = [];
      log.info("New Topology object is created");
    }

    Topology.prototype.systemconfig = function(config) {
      return this.sysconfig = extend({}, config);
    };

    Topology.prototype.getNodeObjbyName = function(name) {
      var j, len, obj, ref;
      log.debug("getNodeObjbyName - input " + name);
      if (name == null) {
        return null;
      }
      ref = this.nodeobj;
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        log.debug("getNodeObjbyName - checking with " + obj.config.name);
        if (obj.config.name === name) {
          log.debug("getNodeObjbyName found " + obj.config.name);
          return obj;
        }
      }
      log.debug("getNodeObjbyName not found " + name);
      return null;
    };

    Topology.prototype.getSwitchObjbyName = function(name) {
      var j, len, obj, ref;
      log.debug("getSwitchObjbyName input  " + name);
      if (name == null) {
        return null;
      }
      ref = this.switchobj;
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        log.debug("getSwitchObjbyName iteraition from the objectarray " + obj.config.name);
        if (obj.config.name === name) {
          log.debug("getSwitchObjbyName found " + obj.config.name);
          return obj;
        }
      }
      log.debug("getSwitchObjbyName not found " + name);
      return null;
    };

    Topology.prototype.getSwitchObjbyUUID = function(uuid) {
      var j, len, obj, ref;
      ref = this.switchobj;
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        log.debug("getSwitchObjbyUUID " + obj.uuid);
        if (obj.uuid === uuid) {
          log.debug("getSwitchObjbyUUID found " + obj.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getNodeObjbyUUID = function(uuid) {
      var j, len, obj, ref;
      ref = this.nodeobj;
      for (j = 0, len = ref.length; j < len; j++) {
        obj = ref[j];
        log.debug("getNodeObjbyUUID" + obj.uuid);
        if (obj.uuid === uuid) {
          log.debug("getNodeObjbyUUID found " + obj.config.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.createSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("createing a  switch " + sw.config.name);
          return sw.create(function(result) {
            log.debug("create switch result " + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("Error occured on createswitches function " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("create switches function completed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.startSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("starting a switch " + sw.config.name);
          sw.start(function(result) {
            return log.info("start switch result " + JSON.stringify(result));
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("start switches all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("createing a node " + n.config.name);
          return n.create(function(result) {
            var create;
            log.info("create node result " + JSON.stringify(result));
            create = false;
            return async.until(function() {
              return create;
            }, function(repeat) {
              return n.getstatus((function(_this) {
                return function(result) {
                  log.info(("node creation " + n.config.name + " status ") + result.data.status);
                  if (result.data.status !== "creation-in-progress") {
                    create = true;
                    n.start(function(result) {
                      log.info(("node start " + n.config.name + " result ") + JSON.stringify(result));
                    });
                  }
                  if (result.data.status === "failed") {
                    return new Error("node creation failed");
                  }
                  return setTimeout(repeat, 15000);
                };
              })(this));
            }, function(err) {
              log.info("createNodes completed");
              return callback(err);
            });
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createNodes error occured " + err);
            return cb(false);
          } else {
            log.info("createNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };


    /*
    #currently not used
     *
    provisionNodes :(cb)->
        async.each @nodeobj, (n,callback) =>
            log.info "provisioning a node #{n.uuid}"
            n.provision (result) =>   
                #Todo : Result to be checked.
                log.info "provision node #{n.uuid} result  " + JSON.stringify  result
                callback()
        ,(err) =>
            if err
                log.error "ProvisionNodes error occured " + JSON.stringify err
                cb(false)
            else
                log.info "provisionNodes all are processed "
                cb (true)
     */

    Topology.prototype.destroyNodes = function() {
      log.info("destroying the Nodes");
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("delete node " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("destroy nodes error occured " + JSON.stringify(err));
            return false;
          } else {
            log.info("destroyNodes all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.destroySwitches = function() {
      log.info("destroying the Switches");
      return async.each(this.switchobj, (function(_this) {
        return function(n, callback) {
          log.info("delete switch " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("Destroy switches error occured " + JSON.stringify(err));
            return false;
          } else {
            log.info("Destroy Switches all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.createNodeLinks = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          var ifmap, j, len, obj, ref;
          log.info("create a Link for a node " + n.config.name);
          ref = n.config.ifmap;
          for (j = 0, len = ref.length; j < len; j++) {
            ifmap = ref[j];
            if (ifmap.veth != null) {
              obj = _this.getSwitchObjbyName(ifmap.brname);
              if (obj === null) {
                assert("switch object " + swn.name + " is not present in switch object array...failed in createnodelinks function");
              }
              if (obj != null) {
                obj.connect(ifmap.veth, function(res) {
                  return log.info("Link connect result" + JSON.stringify(res));
                });
              }
            }
          }
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createNodeLinks error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("createNodeLinks  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createSwitchLinks = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("create a interconnection  switch Link");
          sw.connectTapInterfaces(function(res) {
            return log.info("result", res);
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createSwitchLinks error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("createSwitchLinks  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.ConfigureLinkChars = function(cb) {
      log.info("Topology - configuring the Node to Switch Link characteristics .. ");
      return async.each(this.nodeobj, (function(_this) {
        return function(obj, callback) {
          obj.setLinkChars(function(result) {
            return log.info("Topology - node setLinkChars result " + result);
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("ConfigureLinkChars error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("ConfigureLinkChars  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.ConfigureInterSwitchLinkChars = function(cb) {
      log.info("Topology - configuring the InterSwitch Link characteristics .. ");
      return async.each(this.switchobj, (function(_this) {
        return function(obj, callback) {
          obj.setLinkChars(function(result) {
            return log.info("Topology - Switch setLinkChars result " + result);
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("ConfigureLinkChars error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("ConfigureLinkChars  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.buildSwitchObjects = function() {
      var j, len, obj, ref, results, sw;
      log.info("processing the input switches array " + JSON.stringify(this.config.switches));
      if (this.config.switches != null) {
        log.info("Topology - creating the switches ");
        ref = this.config.switches;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          sw = ref[j];
          sw.make = this.sysconfig.switchtype;
          sw.ofversion = this.sysconfig.ofversion;
          if (sw.type !== "wan") {
            if (this.sysconfig.controller != null) {
              sw.controller = this.sysconfig.controller;
            }
          }
          log.info("Topology - creating a new switch  " + JSON.stringify(sw));
          obj = new switches(sw);
          this.switchobj.push(obj);
          results.push(log.info("Topology - successfully created a switch < " + obj.config.name + " > & pushed in to switchobj array "));
        }
        return results;
      }
    };

    Topology.prototype.buildNodeObjects = function() {
      var j, len, mgmtip, obj, ref, results, val;
      log.info("processing the input nodes array " + JSON.stringify(this.config.nodes));
      ref = this.config.nodes;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        val = ref[j];
        val.virtualization = this.sysconfig.virtualization;
        val.image = this.sysconfig.lxcimage;
        log.info("Topology - creating a new node " + JSON.stringify(val));
        obj = new node(val);
        log.info("Topology - successfully created a new node object " + obj.config.name);
        mgmtip = this.ipmgr.getFreeMgmtIP();
        log.info("Topology - Assigning the mgmtip " + mgmtip + " to the node " + obj.config.name);
        obj.addMgmtInterface(mgmtip, '255.255.255.0');
        log.info("Topology - Pushed the node obj  " + obj.config.name + " in to the object array");
        results.push(this.nodeobj.push(obj));
      }
      return results;
    };

    Topology.prototype.buildLanLink = function(val) {
      var j, len, n, obj, ref, results, startaddress, sw, swobj, temp;
      x = 1;
      log.info("Topology - building  a LAN link " + JSON.stringify(val));
      temp = this.ipmgr.getFreeLanSubnet();
      log.info("Topology - Lan Free subnet is " + JSON.stringify(temp));
      ref = val.switches;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        sw = ref[j];
        log.info("Topology - iterating the switch present in the lan link " + sw.name);
        swobj = this.getSwitchObjbyName(sw.name);
        if (swobj === null) {
          assert("switch object " + sw.name + " is not present in switch object array...something went wrong.");
        }
        if (sw.connected_nodes != null) {
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = sw.connected_nodes;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              n = ref1[k];
              log.info(("Topology - iterating the connected_nodes in the switch " + sw.name + " ") + JSON.stringify(n));
              obj = this.getNodeObjbyName(n.name);
              if (obj === null) {
                assert("node object " + n.name + " is not present in node object array...something went wrong.");
              }
              if (obj != null) {
                if (obj.config.type === "router") {
                  startaddress = temp.firstAddress;
                } else {
                  startaddress = temp.iparray[x++];
                }
                log.info(("Topology -  " + obj.config.name + " Lan address ") + startaddress);
                obj.addLanInterface(sw.name, startaddress, temp.subnetMask, temp.firstAddress, n.config);
                results1.push(log.info("Topology - " + obj.config.name + " added the Lan interface"));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Topology.prototype.buildInterSwitchLink = function(val) {
      var command, dsttaplink, exec, index, j, len, n, obj, ref, results, srctaplink, sw, swobj;
      index = 0;
      log.info("Topology - building  a Interswitch link " + JSON.stringify(val));
      ref = val.switches;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        sw = ref[j];
        log.info("Topology - iterating the switch present in link for interconnecting the switches " + sw.name);
        swobj = this.getSwitchObjbyName(sw.name);
        if (swobj === null) {
          assert("switch object " + sw.name + " is not present in switch object array...something went wrong.");
        }
        if (sw.connected_switches != null) {
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = sw.connected_switches;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              n = ref1[k];
              obj = this.getSwitchObjbyName(n.name);
              if (obj != null) {
                srctaplink = sw.name + "_t" + swobj.tapindex;
                dsttaplink = n.name + "_t" + obj.tapindex;
                exec = require('child_process').exec;
                command = "ip link add " + srctaplink + " type veth peer name " + dsttaplink;
                log.info("Topology - interswitch link creation command - " + command);
                exec(command, (function(_this) {
                  return function(error, stdout, stderr) {};
                })(this));
                swobj.addTapInterface(srctaplink, n.config);
                obj.addTapInterface(dsttaplink, null);
                swobj.tapindex++;
                results1.push(obj.tapindex++);
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Topology.prototype.buildWanLink = function(val) {
      var j, len, n, obj, ref, results, startaddress, sw, swobj, temp;
      x = 0;
      log.info("Topology - building  a WAN link " + JSON.stringify(val));
      temp = this.ipmgr.getFreeWanSubnet();
      sw = val.switches[0];
      swobj = this.getSwitchObjbyName(sw.name);
      if (swobj === null) {
        assert("switch object " + sw.name + " is not present in switch object array...something went wrong.");
      }
      ref = sw.connected_nodes;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        n = ref[j];
        log.info("updating wan interface for ", n.name);
        obj = this.getNodeObjbyName(n.name);
        if (obj != null) {
          startaddress = temp.iparray[x++];
          results.push(obj.addWanInterface(sw.name, startaddress, temp.subnetMask, null, n.config));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Topology.prototype.buildLinks = function() {
      var j, len, ref, results, val;
      log.info("processing the input data links array to build links " + JSON.stringify(this.config.links));
      ref = this.config.links;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        val = ref[j];
        log.info("Topology - creating a link " + JSON.stringify(val));
        if (val.type === "lan") {
          this.buildLanLink(val);
          this.buildInterSwitchLink(val);
        }
        if (val.type === "wan") {
          results.push(this.buildWanLink(val));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Topology.prototype.create = function(tdata) {
      this.tdata = tdata;
      this.config = extend({}, this.tdata.data);
      this.uuid = this.tdata.id;
      log.info("Topology - creation is started with data :  " + JSON.stringify(this.config));
      this.ipmgr = new IPManager(this.sysconfig.wansubnet, this.sysconfig.lansubnet, this.sysconfig.mgmtsubnet);
      log.info("Topology - created a IP Manager object.. ");
      this.buildSwitchObjects();
      this.buildNodeObjects();
      return this.buildLinks();
    };

    Topology.prototype.run = function() {
      log.info("TOPOLOGY--- GETTING IN TO ACTION... Executing the Topology ");
      return async.series([
        (function(_this) {
          return function(callback) {
            log.info("TOPOLOGY ---- CREATING THE SWITCHES FROM THE SWITCH OBJECTS");
            return _this.createSwitches(function(res) {
              log.info("TOPOLOGY ---- CREAET SWITCHES RESULT" + res);
              if (res === true) {
                callback(null, "CREATESWITCHES success");
              }
              if (res !== true) {
                return callback(new Error('CREATESWITCHES failed'));
              }
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            log.info("TOPOLOGY - CREATING THE NODES FROM THE NODES OBJECTS");
            return _this.createNodes(function(res) {
              log.info("TOPOLOGY - CREATE NODES RESULT" + res);
              if (res === true) {
                callback(null, "CREATENODES success");
              }
              if (res !== true) {
                return callback(new Error('CREATENODES failed'));
              }
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            log.info("TOPOLOGY - CREATING THE NODE LINKS - ATTACHING WITH SWITCHES");
            return _this.createNodeLinks(function(res) {
              log.info("TOPOLOGY - CREATE NODE LINKS RESULT " + res);
              if (res === true) {
                callback(null, "CREATE NODE LINKS success");
              }
              if (res !== true) {
                return callback(new Error('CREATE NODE LINKS failed'));
              }
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            log.info("TOPOLOGY - CREATING THE SWITCH LINKS ");
            return _this.createSwitchLinks(function(res) {
              log.info("TOPOLOGY - CREATE SWITCH LINKS RESULT  " + res);
              if (res === true) {
                callback(null, "CREATE SWITCH LINKS success");
              }
              if (res !== true) {
                return callback(new Error('CREATE SWITCH LINKS failed'));
              }
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            log.info("TOPOLOGY - STARTING THE SWITCHES ");
            return _this.startSwitches(function(res) {
              log.info("TOPOLOGY - START SWITCHES RESULT " + res);
              if (res === true) {
                callback(null, "START SWITCHES success");
              }
              if (res !== true) {
                return callback(new Error('START SWITCHES failed'));
              }
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            log.info("TOPOLOGY - CONFIGURING THE NODE LINK characteristics ");
            return _this.ConfigureLinkChars(function(res) {
              log.info("TOPOLOGY - CONFIG LINK NODE CHARS RESULT " + res);
              if (res === true) {
                callback(null, "CONFIG NODE LINK CHAR success");
              }
              if (res !== true) {
                return callback(new Error('CONFIG NODE LINK CHARS failed'));
              }
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            log.info("TOPOLOGY - CONFIGURING THE INTER SWITCH  LINK characteristics ");
            return _this.ConfigureInterSwitchLinkChars(function(res) {
              log.info("TOPOLOGY - CONFIG INTER SWITCH LINK  CHARS RESULT " + res);
              if (res === true) {
                callback(null, "CONFIG INTERSWITCH LINK CHAR success");
              }
              if (res !== true) {
                return callback(new Error('CONFIG INTERSWITCH  LINK CHARS failed'));
              }
            });
          };
        })(this)
      ], (function(_this) {
        return function(err, result) {
          return log.info("TOPOLOGY -  RUN result is  %s ", result);
        };
      })(this));
    };

    Topology.prototype.del = function() {
      var res, res1;
      res = this.destroyNodes();
      res1 = this.destroySwitches();
      return {
        "id": this.uuid,
        "status": "deleted"
      };
    };

    Topology.prototype.get = function() {
      var j, k, len, len1, n, nodestatus, ref, ref1, switchstatus;
      nodestatus = [];
      switchstatus = [];
      ref = this.nodeobj;
      for (j = 0, len = ref.length; j < len; j++) {
        n = ref[j];
        nodestatus.push(n.get());
      }
      ref1 = this.switchobj;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        n = ref1[k];
        switchstatus.push(n.get());
      }
      return {
        "nodes": nodestatus,
        "switches": switchstatus
      };
    };

    Topology.prototype.createTest = function(testdataid, t, sourcenode, destnode) {
      var destnodeip, dnode, sourcenodeip, srcnode, testData, testobj;
      log.info("CreateTest  sourcenode " + sourcenode + "  " + destnode);
      log.info("CreateTest testdataid ", testdataid);
      log.info("CreateTest t t ", t);
      srcnode = this.getNodeObjbyName(sourcenode);
      sourcenodeip = srcnode.mgmtip;
      dnode = this.getNodeObjbyName(destnode);
      destnodeip = dnode.lanip;
      testData = {
        "testsuiteid": testdataid,
        "name": "test_" + t.traffictype + "_" + sourcenode + "_" + destnode,
        "source": sourcenodeip,
        "destination": destnodeip,
        "type": t.traffictype,
        "starttime": t.starttime,
        "duration": t.duration,
        "config": t.trafficconfig
      };
      testobj = new test(testData);
      testobj.run();
      return this.testobjs.push(testobj);
    };

    Topology.prototype.createTestSuite = function(testdata) {
      var i, iter, j, len, ref, results, t;
      log.info("createTest called with " + JSON.stringify(testdata));
      ref = testdata.data.tests;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        t = ref[j];
        log.info("test sourcenodes length", t.sourcenodes.length);
        log.info("test destnodes length ", t.destnodes.length);
        if (t.sourcenodes.length === 1 && t.destnodes.length > 1) {
          log.info("one to many relationship");
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = t.destnodes;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              i = ref1[k];
              results1.push(this.createTest(testdata.id, t, t.sourcenodes[0], i));
            }
            return results1;
          }).call(this));
        } else if (t.destnodes.length === 1 && t.sourcenodes.length > 1) {
          log.info("many to one relationship");
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = t.sourcenodes;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              i = ref1[k];
              results1.push(this.createTest(testdata.id, t, i, t.destnodes[0]));
            }
            return results1;
          }).call(this));
        } else if (t.destnodes.length === t.sourcenodes.length || t.destnodes.length > t.sourcenodes.length) {
          log.info("many to one relationship - dest nodes have more number");
          iter = 0;
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = t.sourcenodes;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              i = ref1[k];
              results1.push(this.createTest(testdata.id, t, i, t.destnodes[iter++]));
            }
            return results1;
          }).call(this));
        } else {
          log.info("many to one relationship - src nodes have more number");
          iter = 0;
          results.push((function() {
            var k, len1, ref1, results1;
            ref1 = t.destnodes;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              i = ref1[k];
              results1.push(this.createTest(testdata.id, t, t.sourcenodes[iter++], i));
            }
            return results1;
          }).call(this));
        }
      }
      return results;
    };

    Topology.prototype.deleteTest = function(testid) {};

    Topology.prototype.getTestStatus = function(testsuiteid, cb) {
      var teststatus;
      teststatus = [];
      return async.each(this.testobjs, (function(_this) {
        return function(obj, callback) {
          if (obj.testsuiteid === testsuiteid) {
            return obj.get(function(result) {
              log.info("Topology - Switch getTestStatus result " + result);
              teststatus.push(result);
              return callback();
            });
          } else {
            return callback();
          }
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("getTestStatus error occured " + JSON.stringify(err));
            return cb(err);
          } else {
            log.info("getTestStatus  all are processed ");
            return cb(teststatus);
          }
        };
      })(this));
    };

    return Topology;

  })();

  TopologyMaster = (function() {
    function TopologyMaster() {
      this.registry = new TopologyRegistry;
      this.testregistry = new TestRegistry;
      this.topologyObj = {};
      this.sysconfig = {};
      log.info("TopologyMaster - constructor - TopologyMaster object is created");
    }

    TopologyMaster.prototype.configure = function(config) {
      this.sysconfig = extend({}, config);
      return log.debug("Topologymaster system config " + JSON.stringify(this.sysconfig));
    };

    TopologyMaster.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    TopologyMaster.prototype.create = function(data, callback) {
      var err, obj, topodata;
      try {
        topodata = new TopologyData(null, data);
      } catch (_error) {
        err = _error;
        log.error("TopologyMaster - create - invalid schema " + JSON.stringify(err));
        return callback(new Error("Invalid Input "));
      } finally {

      }
      log.info("TopologyMaster - Topology Input JSON  schema check is passed " + JSON.stringify(topodata));
      obj = new Topology;
      obj.systemconfig(this.sysconfig);
      obj.create(topodata);
      this.topologyObj[obj.uuid] = obj;
      obj.run();
      return callback(this.registry.add(topodata));
    };

    TopologyMaster.prototype.del = function(id, callback) {
      var obj, result;
      obj = this.topologyObj[id];
      if (obj != null) {
        this.registry.remove(obj.uuid);
        delete this.topologyObj[id];
        result = obj.del();
        return callback(result);
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.get = function(id, callback) {
      var obj;
      obj = this.topologyObj[id];
      if (obj != null) {
        return callback(obj.get());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };


    /*
    #currently not used
    deviceStats: (topolid, deviceid, callback) ->
        obj = @topologyObj[topolid]
        if obj? 
            deviceobj = obj.getNodeObjbyUUID(deviceid)
            if deviceobj?
                deviceobj.stats (result)=>
                    callback result
            else                
                callback new Error "Unknown Device ID"
        else
            callback new Error "Unknown Topology ID"
     */

    TopologyMaster.prototype.deviceGet = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.getstatus((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };


    /*
    #currently not used
    deviceStatus: (topolid, deviceid, callback) ->
        obj = @topologyObj[topolid]
        if obj? 
            deviceobj = obj.getNodeObjbyUUID(deviceid)
            if deviceobj?
                deviceobj.getrunningstatus (result)=>
                    return callback result
            else                
                return callback new Error "Unknown Device ID"
        else
            return callback new Error "Unknown Topology ID"
     */

    TopologyMaster.prototype.deviceStart = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.start((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStop = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stop((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };


    /*
     * currently not used
    deviceTrace: (topolid, deviceid, callback) ->
        obj = @topologyObj[topolid]        
        if obj? 
            deviceobj = obj.getNodeObjbyUUID(deviceid)
            if deviceobj?
                deviceobj.trace (result)=>
                    callback result
            else                
                return callback new Error "Unknown Device ID"
        else
            return callback new Error "Unknown Topology ID"
     */

    TopologyMaster.prototype.deviceDelete = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.del((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.testSuiteCreate = function(topolid, data, callback) {
      var err, obj, testdata;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        try {
          testdata = new TestData(null, data);
        } catch (_error) {
          err = _error;
          log.error("TopologyMaster - Test create - invalid schema " + JSON.stringify(err));
          return callback(new Error("Invalid Input "));
        } finally {

        }
        log.info("TopologyMaster - Test Input JSON  schema check is passed " + JSON.stringify(testdata));
        obj.createTestSuite(testdata);
        return callback(this.testregistry.add(testdata));
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.testSuiteList = function(topolid, callback) {
      var obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        return callback(this.testregistry.list());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.testSuiteGet = function(topolid, testsuiteid, callback) {
      var obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        return obj.getTestStatus(testsuiteid, (function(_this) {
          return function(result) {
            log.info("main routine testsuite get ", result);
            return callback(result);
          };
        })(this));
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.testSuiteDelete = function(topolid, testsuiteid, callback) {
      var obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        obj.deleteTest(testsuiteid);
        return this.testregistry.remove(testsuiteid);
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    return TopologyMaster;

  })();

  module.exports = new TopologyMaster;

}).call(this);
