// Generated by CoffeeScript 1.9.3
(function() {
  var IPManager, StormData, StormRegistry, Topology, TopologyData, TopologyMaster, TopologyRegistry, assert, async, extend, ip, log, node, request, switches, util,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  assert = require('assert');

  StormRegistry = require('stormregistry');

  StormData = require('stormdata');

  util = require('util');

  request = require('request-json');

  extend = require('util')._extend;

  ip = require('ip');

  async = require('async');

  util = require('util');

  IPManager = require('./IPManager');

  node = require('./Node');

  switches = require('./Switches');

  log = require('./utils/logger').getLogger();

  log.info("Topology Logger test message");

  TopologyRegistry = (function(superClass) {
    extend1(TopologyRegistry, superClass);

    function TopologyRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new TopologyData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      TopologyRegistry.__super__.constructor.call(this, filename);
    }

    TopologyRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof TopologyData)) {
        return;
      }
      return entry = TopologyRegistry.__super__.add.call(this, data.id, data);
    };

    TopologyRegistry.prototype.update = function(data) {
      return TopologyRegistry.__super__.update.call(this, data.id, data);
    };

    TopologyRegistry.prototype.get = function(key) {
      var entry;
      entry = TopologyRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof TopologyData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return TopologyRegistry;

  })(StormRegistry);

  TopologyData = (function(superClass) {
    var TopologySchema;

    extend1(TopologyData, superClass);

    TopologySchema = {
      name: "Topology",
      type: "object",
      properties: {
        name: {
          type: "string",
          required: true
        },
        switches: {
          type: "array",
          items: {
            name: "switch",
            type: "object",
            required: true,
            properties: {
              name: {
                type: "string",
                required: false
              },
              type: {
                type: "string",
                required: false
              }
            }
          }
        },
        nodes: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              name: {
                type: "string",
                required: true
              }
            }
          }
        },
        links: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              type: {
                type: "string",
                required: true
              },
              switches: {
                type: "array",
                required: false,
                items: {
                  type: "object",
                  required: false
                }
              },
              connected_nodes: {
                type: "array",
                required: false,
                items: {
                  type: "object",
                  required: false,
                  properties: {
                    name: {
                      "type": "string",
                      "required": true
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    function TopologyData(id, data) {
      TopologyData.__super__.constructor.call(this, id, data, TopologySchema);
    }

    return TopologyData;

  })(StormData);

  Topology = (function() {
    function Topology() {
      this.config = {};
      this.sysconfig = {};
      this.status = {};
      this.statistics = {};
      this.switchobj = [];
      this.nodeobj = [];
      this.linksobj = [];
      log.info("New Topology object is created");
    }

    Topology.prototype.systemconfig = function(config) {
      return this.sysconfig = extend({}, config);
    };

    Topology.prototype.getNodeObjbyName = function(name) {
      var i, len, obj, ref;
      log.debug("getNodeObjbyName - input " + name);
      if (name == null) {
        retun(null);
      }
      ref = this.nodeobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getNodeObjbyName - checking with " + obj.config.name);
        if (obj.config.name === name) {
          log.debug("getNodeObjbyName found " + obj.config.name);
          return obj;
        }
      }
      log.debug("getNodeObjbyName not found " + name);
      return null;
    };

    Topology.prototype.getSwitchObjbyName = function(name) {
      var i, len, obj, ref;
      log.debug("getSwitchObjbyName input  " + name);
      if (name == null) {
        retun(null);
      }
      ref = this.switchobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getSwitchObjbyName iteraition from the objectarray " + obj.config.name);
        if (obj.config.name === name) {
          log.debug("getSwitchObjbyName found " + obj.config.name);
          return obj;
        }
      }
      log.debug("getSwitchObjbyName not found " + name);
      return null;
    };

    Topology.prototype.getSwitchObjbyUUID = function(uuid) {
      var i, len, obj, ref;
      ref = this.switchobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getSwitchObjbyUUID " + obj.uuid);
        if (obj.uuid === uuid) {
          log.debug("getSwitchObjbyUUID found " + obj.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getNodeObjbyUUID = function(uuid) {
      var i, len, obj, ref;
      ref = this.nodeobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getNodeObjbyUUID" + obj.uuid);
        if (obj.uuid === uuid) {
          log.debug("getNodeObjbyUUID found " + obj.config.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.createSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("createing a  switch " + sw.config.name);
          return sw.create(function(result) {
            log.debug("create switch result " + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("Error occured on createswitches function " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("create switches function completed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.startSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("starting a switch " + sw.config.name);
          sw.start(function(result) {
            return log.info("start switch result " + JSON.stringify(result));
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("start switches all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("createing a node " + n.config.name);
          return n.create(function(result) {
            var create;
            log.info("create node result " + JSON.stringify(result));
            create = false;
            return async.until(function() {
              return create;
            }, function(repeat) {
              return n.getstatus((function(_this) {
                return function(result) {
                  log.info(("node creation " + n.config.name + " status ") + result.data.status);
                  if (result.data.status !== "creation-in-progress") {
                    create = true;
                    n.start(function(result) {
                      log.info(("node start " + n.config.name + " result ") + JSON.stringify(result));
                    });
                  }
                  return setTimeout(repeat, 30000);
                };
              })(this));
            }, function(err) {
              log.info("createNodes completed");
              return callback(err);
            });
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createNodes error occured " + err);
            return cb(false);
          } else {
            log.info("createNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.provisionNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("provisioning a node " + n.uuid);
          return n.provision(function(result) {
            log.info(("provision node " + n.uuid + " result  ") + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("ProvisionNodes error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("provisionNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.destroyNodes = function() {
      log.info("destroying the Nodes");
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("delete node " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("destroy nodes error occured " + JSON.stringify(err));
            return false;
          } else {
            log.info("destroyNodes all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.destroySwitches = function() {
      log.info("destroying the Switches");
      return async.each(this.switchobj, (function(_this) {
        return function(n, callback) {
          log.info("delete switch " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("Destroy switches error occured " + JSON.stringify(err));
            return false;
          } else {
            log.info("Destroy Switches all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.createNodeLinks = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          var i, ifmap, len, obj, ref;
          log.info("create a Link for a node " + n.config.name);
          ref = n.config.ifmap;
          for (i = 0, len = ref.length; i < len; i++) {
            ifmap = ref[i];
            if (ifmap.veth != null) {
              obj = _this.getSwitchObjbyName(ifmap.brname);
              if (obj === null) {
                assert("switch object " + swn.name + " is not present in switch object array...failed in createnodelinks function");
              }
              if (obj != null) {
                obj.connect(ifmap.veth, function(res) {
                  return log.info("Link connect result" + res);
                });
              }
            }
          }
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createNodeLinks error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("createNodeLinks  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createSwitchLinks = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("create a interconnection  switch Link");
          sw.connectTapInterfaces(function(res) {
            return log.info("result", res);
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createSwitchLinks error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("createSwitchLinks  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.create = function(tdata) {
      var i, ipmgr, j, k, l, len, len1, len2, len3, len4, len5, m, mgmtip, n, o, obj, ref, ref1, ref2, ref3, ref4, ref5, sindex, startaddress, sw, swname, swobj, temp, val, x;
      this.tdata = tdata;
      this.config = extend({}, this.tdata);
      this.uuid = this.tdata.id;
      log.info("Topology - creation is started with data :  " + JSON.stringify(this.config));
      ipmgr = new IPManager(this.sysconfig.wansubnet, this.sysconfig.lansubnet, this.sysconfig.mgmtsubnet);
      log.info("Topology - created a IP Manager object.. ");
      log.info("processing the input switches array " + JSON.stringify(this.tdata.data.switches));
      if (this.tdata.data.switches != null) {
        log.info("Topology - creating the switches ");
        ref = this.tdata.data.switches;
        for (i = 0, len = ref.length; i < len; i++) {
          sw = ref[i];
          sw.make = this.sysconfig.switchtype;
          if (this.sysconfig.controller != null) {
            sw.controller = this.sysconfig.controller;
          }
          log.info("Topology - creating a new switch  " + JSON.stringify(sw));
          obj = new switches(sw);
          this.switchobj.push(obj);
          log.info("Topology - successfully created a switch < " + obj.config.name + " > & pushed in to switchobj array ");
        }
      }
      log.info("processing the input nodes array " + JSON.stringify(this.tdata.data.nodes));
      ref1 = this.tdata.data.nodes;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        val = ref1[j];
        log.info("Topology - creating a new node " + JSON.stringify(val));
        obj = new node(val);
        log.info("Topology - successfully created a new node object " + obj.config.name);
        mgmtip = ipmgr.getFreeMgmtIP();
        log.info("Topology - Assigning the mgmtip " + mgmtip + " to the node " + obj.config.name);
        obj.addMgmtInterface(mgmtip, '255.255.255.0');
        log.info("Topology - Pushed the node obj  " + obj.config.name + " in to the object array");
        this.nodeobj.push(obj);
      }
      sindex = 1;
      log.info("processing the input data links array " + JSON.stringify(this.tdata.data.links));
      ref2 = this.tdata.data.links;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        val = ref2[k];
        x = 0;
        log.info("Topology - creating a link " + JSON.stringify(val));
        if (val.type === "lan") {
          temp = ipmgr.getFreeLanSubnet();
          log.info("Topology - Lan Free subnet is " + JSON.stringify(temp));
          ref3 = val.switches;
          for (l = 0, len3 = ref3.length; l < len3; l++) {
            sw = ref3[l];
            log.info("Topology - iterating the switch present in the lan link " + sw.name);
            swobj = this.getSwitchObjbyName(sw.name);
            if (swobj === null) {
              assert("switch object " + sw.name + " is not present in switch object array...something went wrong.");
            }
            ref4 = sw.connected_nodes;
            for (m = 0, len4 = ref4.length; m < len4; m++) {
              n = ref4[m];
              log.info(("Topology - iterating the connected_nodes in the switch " + sw.name + " ") + JSON.stringify(n));
              obj = this.getNodeObjbyName(n.name);
              if (obj === null) {
                assert("node object " + n.name + " is not present in node object array...something went wrong.");
              }
              if (obj != null) {
                startaddress = temp.iparray[x++];
                log.info(("Topology -  " + obj.config.name + " Lan address ") + startaddress);
                obj.addLanInterface(sw.name, startaddress, temp.subnetMask, temp.iparray[0], null);
                log.info("Topology - " + obj.config.name + " added the Lan interface");
              }
            }

            /*
            if sw.connected_switches?
                for swn in  sw.connected_switches
                    log.info "Topology - iterating the connected_switches in the switch #{sw.name} " + JSON.stringify swn
                    obj1 = @getSwitchObjbyName(swn.name)
                    if obj1 is null
                        assert "switch object #{swn.name} is not present in switch object array...something went wrong."    
                
                    if obj1?                            
                        log.info "Topology - Setting up the interswitch connection #{sw.name} #{swn.name} "
                        srctaplink = "#{sw.name}_#{swn.name}"
                        dsttaplink = "#{swn.name}_#{sw.name}"                                                        
                        #swobj.createTapInterfaces srctaplink,dsttaplink
                        exec = require('child_process').exec
                        command = "ip link add #{srctaplink} type veth peer name #{dsttaplink}"
                        log.info "Topology executing command for tap device creation " + command
                        exec command, (error, stdout, stderr) =>
            
                        #console.log "createTapinterfaces completed", result
                        obj1.addTapInterface(dsttaplink) 
                        swobj.addTapInterface(srctaplink)
             */
          }
        }
        if (val.type === "wan") {
          temp = ipmgr.getFreeWanSubnet();
          swname = val.type + "_sw" + sindex;
          sindex++;
          log.debug("  wan swname is " + swname);
          obj = new switches({
            name: swname,
            ports: 2,
            type: val.type,
            make: this.sysconfig.switchtype,
            controller: this.sysconfig.controller != null ? this.sysconfig.controller : void 0
          });
          this.switchobj.push(obj);
          ref5 = val.connected_nodes;
          for (o = 0, len5 = ref5.length; o < len5; o++) {
            n = ref5[o];
            console.log(n.name);
            log.info("updating wan interface for ", n.name);
            obj = this.getNodeObjbyName(n.name);
            if (obj != null) {
              startaddress = temp.iparray[x++];
              obj.addWanInterface(swname, startaddress, temp.subnetMask, null, val.config);
            }
          }
        }
      }
      log.info("TOPOLOGY--- GETTING IN TO ACTION ");
      log.info("TOPOLOGY ---- CREATING THE SWITCHES FROM THE SWITCH OBJECTS");
      return this.createSwitches((function(_this) {
        return function(res) {
          log.info("TOPOLOGY ---- CREAT SWITCHES RESULT" + res);
          log.info("TOPOLOGY - CREATING THE NODES FROM THE NODES OBJECTS");
          return _this.createNodes(function(res) {
            log.info("TOPOLOGY - CREATE NODES RESULT" + res);
            log.info("TOPOLOGY - CREATING THE NODE LINKS - ATTACHING WITH SWITCHES");
            return _this.createNodeLinks(function(res) {
              log.info("TOPOLOGY - CREATE NODE LINKS RESULT " + res);
              log.info("TOPOLOGY - CREATING THE SWITCH LINKS ");
              return _this.createSwitchLinks(function(res) {
                log.info("TOPOLOGY - CREATE SWITCH LINKS RESULT  " + res);
                log.info("TOPOLOGY - STARTING THE SWITCHES ");
                return _this.startSwitches(function(res) {
                  log.info("TOPOLOGY - START SWITCHES RESULT " + res);
                  return log.info("***Topology creation completed****");
                });
              });
            });
          });
        };
      })(this));
    };

    Topology.prototype.del = function() {
      var res, res1;
      res = this.destroyNodes();
      res1 = this.destroySwitches();
      return {
        "id": this.uuid,
        "status": "deleted"
      };
    };

    Topology.prototype.get = function() {
      var i, j, len, len1, n, nodestatus, ref, ref1, switchstatus;
      nodestatus = [];
      switchstatus = [];
      ref = this.nodeobj;
      for (i = 0, len = ref.length; i < len; i++) {
        n = ref[i];
        nodestatus.push(n.get());
      }
      ref1 = this.switchobj;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        n = ref1[j];
        switchstatus.push(n.get());
      }
      return {
        "nodes": nodestatus,
        "switches": switchstatus
      };
    };

    return Topology;

  })();

  TopologyMaster = (function() {
    function TopologyMaster() {
      this.registry = new TopologyRegistry;
      this.topologyObj = {};
      this.sysconfig = {};
      log.info("TopologyMaster - constructor - TopologyMaster object is created");
    }

    TopologyMaster.prototype.configure = function(config) {
      this.sysconfig = extend({}, config);
      return log.debug("Topologymaster system config " + JSON.stringify(this.sysconfig));
    };

    TopologyMaster.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    TopologyMaster.prototype.create = function(data, callback) {
      var err, obj, topodata;
      try {
        topodata = new TopologyData(null, data);
      } catch (_error) {
        err = _error;
        log.error("TopologyMaster - create - invalid schema " + JSON.stringify(err));
        return callback(new Error("Invalid Input "));
      } finally {

      }
      log.info("TopologyMaster - Topology Input JSON  schema check is passed " + JSON.stringify(topodata));
      obj = new Topology;
      obj.systemconfig(this.sysconfig);
      obj.create(topodata);
      this.topologyObj[obj.uuid] = obj;
      return callback(this.registry.add(topodata));
    };

    TopologyMaster.prototype.del = function(id, callback) {
      var obj, result;
      obj = this.topologyObj[id];
      if (obj != null) {
        this.registry.remove(obj.uuid);
        delete this.topologyObj[id];
        result = obj.del();
        return callback(result);
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.get = function(id, callback) {
      var obj;
      obj = this.topologyObj[id];
      if (obj != null) {
        return callback(obj.get());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStats = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stats((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceGet = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.getstatus((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStatus = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.getrunningstatus((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStart = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.start((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStop = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stop((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceTrace = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.trace((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceDelete = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.del((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    return TopologyMaster;

  })();

  module.exports = new TopologyMaster;

}).call(this);
