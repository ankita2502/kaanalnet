// Generated by CoffeeScript 1.9.3
(function() {
  var IPManager, StormData, StormRegistry, Topology, TopologyData, TopologyMaster, TopologyRegistry, async, extend, ip, log, node, request, switches, util,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StormRegistry = require('stormregistry');

  StormData = require('stormdata');

  util = require('util');

  request = require('request-json');

  extend = require('util')._extend;

  ip = require('ip');

  async = require('async');

  util = require('util');

  IPManager = require('./IPManager');

  node = require('./Node');

  switches = require('./Switches');

  log = require('./utils/logger').getLogger();

  log.info("Topology Logger test message");

  TopologyRegistry = (function(superClass) {
    extend1(TopologyRegistry, superClass);

    function TopologyRegistry(filename) {
      this.on('load', function(key, val) {
        var entry;
        entry = new TopologyData(key, val);
        if (entry != null) {
          entry.saved = true;
          return this.add(entry);
        }
      });
      this.on('removed', function(entry) {
        if (entry.destructor != null) {
          return entry.destructor();
        }
      });
      TopologyRegistry.__super__.constructor.call(this, filename);
    }

    TopologyRegistry.prototype.add = function(data) {
      var entry;
      if (!(data instanceof TopologyData)) {
        return;
      }
      return entry = TopologyRegistry.__super__.add.call(this, data.id, data);
    };

    TopologyRegistry.prototype.update = function(data) {
      return TopologyRegistry.__super__.update.call(this, data.id, data);
    };

    TopologyRegistry.prototype.get = function(key) {
      var entry;
      entry = TopologyRegistry.__super__.get.call(this, key);
      if (entry == null) {
        return;
      }
      if ((entry.data != null) && entry.data instanceof TopologyData) {
        entry.data.id = entry.id;
        return entry.data;
      } else {
        return entry;
      }
    };

    return TopologyRegistry;

  })(StormRegistry);

  TopologyData = (function(superClass) {
    var TopologySchema;

    extend1(TopologyData, superClass);

    TopologySchema = {
      name: "Topology",
      type: "object",
      properties: {
        name: {
          type: "string",
          required: true
        },
        switches: {
          type: "array",
          items: {
            name: "switch",
            type: "object",
            required: true,
            properties: {
              name: {
                type: "string",
                required: false
              },
              type: {
                type: "string",
                required: false
              }
            }
          }
        },
        nodes: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              name: {
                type: "string",
                required: true
              }
            }
          }
        },
        links: {
          type: "array",
          items: {
            name: "node",
            type: "object",
            required: true,
            properties: {
              type: {
                type: "string",
                required: true
              },
              switches: {
                type: "array",
                required: false,
                items: {
                  type: "object",
                  required: false
                }
              },
              connected_nodes: {
                type: "array",
                required: false,
                items: {
                  type: "object",
                  required: false,
                  properties: {
                    name: {
                      "type": "string",
                      "required": true
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    function TopologyData(id, data) {
      TopologyData.__super__.constructor.call(this, id, data, TopologySchema);
    }

    return TopologyData;

  })(StormData);

  Topology = (function() {
    function Topology() {
      this.config = {};
      this.sysconfig = {};
      this.status = {};
      this.statistics = {};
      this.switchobj = [];
      this.nodeobj = [];
      this.linksobj = [];
    }

    Topology.prototype.systemconfig = function(config) {
      return this.sysconfig = extend({}, config);
    };

    Topology.prototype.getNodeObjbyName = function(name) {
      var i, len, obj, ref;
      log.debug("getNodeObjbyName - input " + name);
      ref = this.nodeobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getNodeObjbyName - checking with " + obj.config.name);
        if (obj.config.name === name) {
          log.debug("getNodeObjbyName found " + obj.config.name);
          return obj;
        }
      }
      log.debug("getNodeObjbyName not found " + name);
      return null;
    };

    Topology.prototype.getSwitchObjbyName = function(name) {
      var i, len, obj, ref;
      log.debug("inpjut for check " + name);
      ref = this.switchobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getSwitchObjbyName iteratkon " + obj.config.name);
        if (obj.config.name === name) {
          log.debug("getSwitchObjbyName found " + obj.config.name);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getSwitchObjbyUUID = function(uuid) {
      var i, len, obj, ref;
      ref = this.switchobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getSwitchObjbyUUID " + obj.uuid);
        if (obj.uuid === uuid) {
          log.debug("getSwitchObjbyUUID found " + obj.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.getNodeObjbyUUID = function(uuid) {
      var i, len, obj, ref;
      ref = this.nodeobj;
      for (i = 0, len = ref.length; i < len; i++) {
        obj = ref[i];
        log.debug("getNodeObjbyUUID" + obj.uuid);
        if (obj.uuid === uuid) {
          log.debug("getNodeObjbyUUID found " + obj.config.uuid);
          return obj;
        }
      }
      return null;
    };

    Topology.prototype.createSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("create switch ");
          return sw.create(function(result) {
            log.debug("create switch result " + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("Error occured on createswitches function " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("createswitches completed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.startSwitches = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("start switch ");
          sw.start(function(result) {
            return log.info("start switch result " + JSON.stringify(result));
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("startswitches all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("createing a node ");
          return n.create(function(result) {
            var create;
            log.info("create node result " + JSON.stringify(result));
            create = false;
            return async.until(function() {
              return create;
            }, function(repeat) {
              return n.getstatus((function(_this) {
                return function(result) {
                  log.info(("node creation " + n.uuid + " status ") + result.data.status);
                  if (result.data.status !== "creation-in-progress") {
                    create = true;
                    n.start(function(result) {
                      log.info(("node start " + n.uuid + " result ") + JSON.stringify(result));
                    });
                  }
                  return setTimeout(repeat, 30000);
                };
              })(this));
            }, function(err) {
              log.info("createNodes completed execution");
              return callback(err);
            });
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createNodes error occured " + err);
            return cb(false);
          } else {
            log.info("createNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.provisionNodes = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("provisioning a node " + n.uuid);
          return n.provision(function(result) {
            log.info(("provision node " + n.uuid + " result  ") + JSON.stringify(result));
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("ProvisionNodes error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("provisionNodes all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.destroyNodes = function() {
      log.info("destroying the Nodes");
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          log.info("delete node " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("destroy nodes error occured " + JSON.stringify(err));
            return false;
          } else {
            log.info("destroyNodes all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.destroySwitches = function() {
      log.info("destroying the Switches");
      return async.each(this.switchobj, (function(_this) {
        return function(n, callback) {
          log.info("delete switch " + n.uuid);
          return n.del(function(result) {
            return callback();
          });
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("Destroy switches error occured " + JSON.stringify(err));
            return false;
          } else {
            log.info("Destroy Switches all are processed " + _this.tmparray);
            return true;
          }
        };
      })(this));
    };

    Topology.prototype.createNodeLinks = function(cb) {
      return async.each(this.nodeobj, (function(_this) {
        return function(n, callback) {
          var i, ifmap, len, obj, ref;
          log.info("create a Link");
          ref = n.config.ifmap;
          for (i = 0, len = ref.length; i < len; i++) {
            ifmap = ref[i];
            if (ifmap.veth != null) {
              obj = _this.getSwitchObjbyName(ifmap.brname);
              if (obj != null) {
                obj.connect(ifmap.veth, function(res) {
                  return log.info("Link connect result" + res);
                });
              }
            }
          }
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createNodeLinks error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("createNodeLinks  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.createSwitchLinks = function(cb) {
      return async.each(this.switchobj, (function(_this) {
        return function(sw, callback) {
          log.info("create a interconnection  switch Link");
          sw.connectTapInterfaces(function(res) {
            return log.info("result", res);
          });
          return callback();
        };
      })(this), (function(_this) {
        return function(err) {
          if (err) {
            log.error("createSwitchLinks error occured " + JSON.stringify(err));
            return cb(false);
          } else {
            log.info("createSwitchLinks  all are processed ");
            return cb(true);
          }
        };
      })(this));
    };

    Topology.prototype.create = function(tdata) {
      var command, dsttaplink, exec, i, ipmgr, j, k, l, len, len1, len2, len3, len4, len5, len6, m, mgmtip, n, o, obj, p, ref, ref1, ref2, ref3, ref4, ref5, ref6, sindex, srctaplink, startaddress, sw, swname, swobj, temp, val, x;
      this.tdata = tdata;
      this.config = extend({}, this.tdata);
      this.uuid = this.tdata.id;
      log.info("Topology - create - configdata " + JSON.stringify(this.config));
      ipmgr = new IPManager(this.sysconfig.wansubnet, this.sysconfig.lansubnet, this.sysconfig.mgmtsubnet);
      if (this.tdata.data.switches != null) {
        ref = this.tdata.data.switches;
        for (i = 0, len = ref.length; i < len; i++) {
          sw = ref[i];
          sw.make = this.sysconfig.switchtype;
          sw.controller = this.sysconfig.controller;
          obj = new switches(sw);
          this.switchobj.push(obj);
        }
      }
      ref1 = this.tdata.data.nodes;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        val = ref1[j];
        obj = new node(val);
        mgmtip = ipmgr.getFreeMgmtIP();
        obj.addMgmtInterface(mgmtip, '255.255.255.0');
        this.nodeobj.push(obj);
      }
      sindex = 1;
      ref2 = this.tdata.data.links;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        val = ref2[k];
        x = 0;
        if (val.type === "lan") {
          temp = ipmgr.getFreeLanSubnet();
          ref3 = val.switches;
          for (l = 0, len3 = ref3.length; l < len3; l++) {
            sw = ref3[l];
            log.info("processing the switch ", sw.name);
            swobj = this.getSwitchObjbyName(sw.name);
            ref4 = sw.connected_nodes;
            for (m = 0, len4 = ref4.length; m < len4; m++) {
              n = ref4[m];
              obj = this.getNodeObjbyName(n.name);
              if (obj != null) {
                startaddress = temp.iparray[x++];
                obj.addLanInterface(sw.name, startaddress, temp.subnetMask, temp.iparray[0], sw.config);
              }
            }
            if (sw.connected_switches != null) {
              ref5 = sw.connected_switches;
              for (o = 0, len5 = ref5.length; o < len5; o++) {
                n = ref5[o];
                obj = this.getSwitchObjbyName(n.name);
                if (obj != null) {
                  srctaplink = sw.name + "_" + n.name;
                  dsttaplink = n.name + "_" + sw.name;
                  exec = require('child_process').exec;
                  command = "ip link add " + srctaplink + " type veth peer name " + dsttaplink;
                  exec(command, (function(_this) {
                    return function(error, stdout, stderr) {};
                  })(this));
                  obj.addTapInterface(dsttaplink);
                  swobj.addTapInterface(srctaplink);
                }
              }
            }
          }
        }
        if (val.type === "wan") {
          temp = ipmgr.getFreeWanSubnet();
          swname = val.type + "_sw" + sindex;
          sindex++;
          log.debug("  wan swname is " + swname);
          obj = new switches({
            name: swname,
            ports: 2,
            type: val.type,
            make: this.sysconfig.switchtype,
            controller: this.sysconfig.controller
          });
          this.switchobj.push(obj);
          ref6 = val.connected_nodes;
          for (p = 0, len6 = ref6.length; p < len6; p++) {
            n = ref6[p];
            console.log(n.name);
            log.info("updating wan interface for ", n.name);
            obj = this.getNodeObjbyName(n.name);
            if (obj != null) {
              startaddress = temp.iparray[x++];
              obj.addWanInterface(swname, startaddress, temp.subnetMask, null, val.config);
            }
          }
        }
      }
      return this.createSwitches((function(_this) {
        return function(res) {
          log.info("createswitches result" + res);
          return _this.createNodes(function(res) {
            log.info("topologycreation status" + res);
            return _this.createNodeLinks(function(res) {
              log.info("create Nodelinks result " + res);
              return _this.createSwitchLinks(function(res) {
                log.info("create Switchlinks result " + res);
                return _this.startSwitches(function(res) {
                  log.info("start switches result " + res);
                  return log.info("Topology creation completed");
                });
              });
            });
          });
        };
      })(this));
    };

    Topology.prototype.del = function() {
      var res, res1;
      res = this.destroyNodes();
      res1 = this.destroySwitches();
      return {
        "id": this.uuid,
        "status": "deleted"
      };
    };

    Topology.prototype.get = function() {
      var i, j, len, len1, n, nodestatus, ref, ref1, switchstatus;
      nodestatus = [];
      switchstatus = [];
      ref = this.nodeobj;
      for (i = 0, len = ref.length; i < len; i++) {
        n = ref[i];
        nodestatus.push(n.get());
      }
      ref1 = this.switchobj;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        n = ref1[j];
        switchstatus.push(n.get());
      }
      return {
        "nodes": nodestatus,
        "switches": switchstatus
      };
    };

    return Topology;

  })();

  TopologyMaster = (function() {
    function TopologyMaster(filename) {
      if (filename != null) {
        this.registry = new TopologyRegistry(filename);
      }
      if (filename == null) {
        this.registry = new TopologyRegistry;
      }
      this.topologyObj = {};
      this.sysconfig = {};
      log.info("TopologyMaster - constructor - TopologyMaster object is created");
    }

    TopologyMaster.prototype.configure = function(config) {
      this.sysconfig = extend({}, config);
      return log.debug("Topologymaster system config " + JSON.stringify(this.sysconfig));
    };

    TopologyMaster.prototype.list = function(callback) {
      return callback(this.registry.list());
    };

    TopologyMaster.prototype.create = function(data, callback) {
      var err, obj, topodata;
      try {
        topodata = new TopologyData(null, data);
      } catch (_error) {
        err = _error;
        log.error("TopologyMaster - create - invalid schema " + JSON.stringify(err));
        return callback(new Error("Invalid Input "));
      } finally {

      }
      log.info("TopologyMaster - create - creating a new Topology with " + JSON.stringify(topodata));
      obj = new Topology;
      obj.systemconfig(this.sysconfig);
      obj.create(topodata);
      this.topologyObj[obj.uuid] = obj;
      return callback(this.registry.add(topodata));
    };

    TopologyMaster.prototype.del = function(id, callback) {
      var obj, result;
      obj = this.topologyObj[id];
      if (obj != null) {
        this.registry.remove(obj.uuid);
        delete this.topologyObj[id];
        result = obj.del();
        return callback(result);
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.get = function(id, callback) {
      var obj;
      obj = this.topologyObj[id];
      if (obj != null) {
        return callback(obj.get());
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStats = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stats((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceGet = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.getstatus((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStatus = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.getrunningstatus((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStart = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.start((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceStop = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.stop((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceTrace = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.trace((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    TopologyMaster.prototype.deviceDelete = function(topolid, deviceid, callback) {
      var deviceobj, obj;
      obj = this.topologyObj[topolid];
      if (obj != null) {
        deviceobj = obj.getNodeObjbyUUID(deviceid);
        if (deviceobj != null) {
          return deviceobj.del((function(_this) {
            return function(result) {
              return callback(result);
            };
          })(this));
        } else {
          return callback(new Error("Unknown Device ID"));
        }
      } else {
        return callback(new Error("Unknown Topology ID"));
      }
    };

    return TopologyMaster;

  })();

  module.exports = new TopologyMaster;

}).call(this);
